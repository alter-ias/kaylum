<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Tipografía Fluida - tipo250</title>
    <style>
        /* La fuente se carga desde la ruta especificada */
        @font-face {
            font-family: 'MiTipografia'; /* Le damos un nombre para usarlo en el código */
            src: url('assets/fuentes/tipo250.ttf') format('truetype');
        }

        /* Estilos básicos de la página */
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000000;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .info {
            position: fixed;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.4);
            font-family: sans-serif;
            font-size: 14px;
            pointer-events: none;
            text-align: center;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    <div class="info">Mueve el cursor para interactuar con la tipografía</div>

    <script>
    'use strict';

    // ================================================================
    // --- PERSONALIZA TU ANIMACIÓN AQUÍ ---
    // ================================================================
    
    // El texto que quieres que aparezca en la pantalla.
    const TEXT_TO_ANIMATE = 'TIPO 250'; 
    
    // El nombre de la fuente que definiste en el CSS (en @font-face).
    const FONT_FAMILY = 'MiTipografia';
    
    // El tamaño de la fuente en píxeles.
    const FONT_SIZE = 180; 

    // --- Configuración avanzada de la simulación (puedes experimentar con esto) ---
    const config = {
        SIM_RESOLUTION: 128,
        DYE_RESOLUTION: 1024,
        DENSITY_DISSIPATION: 1.2,
        VELOCITY_DISSIPATION: 0.3,
        PRESSURE: 0.8,
        PRESSURE_ITERATIONS: 20,
        CURL: 30,
        SPLAT_RADIUS: 0.3,
        SPLAT_FORCE: 6000,
        SHADING: true,
        COLORFUL: true,
        BACK_COLOR: { r: 0, g: 0, b: 0 }
    };

    // ================================================================
    // --- INICIO DEL CÓDIGO DE LA SIMULACIÓN (NO ES NECESARIO TOCAR) ---
    // ================================================================

    document.addEventListener('DOMContentLoaded', async () => {
        const canvas = document.getElementById('glCanvas');
        let gl;
        try {
            gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        } catch (e) {}

        if (!gl) {
            alert('Tu navegador no soporta WebGL. La animación no puede funcionar.');
            return;
        }

        // --- Carga de la fuente de forma segura ---
        const fontPath = 'assets/fuentes/tipo250.ttf';
        try {
            const font = new FontFace(FONT_FAMILY, `url(${fontPath})`);
            await font.load();
            document.fonts.add(font);
            console.log(`Fuente '${FONT_FAMILY}' cargada correctamente desde ${fontPath}`);
        } catch(err) {
            console.error(`Error al cargar la fuente desde ${fontPath}.`, err);
            alert(`No se pudo cargar la fuente. Verifica que la ruta '${fontPath}' sea correcta y que el archivo exista.`);
            // A pesar del error, intentamos continuar para que se vea algo (con la fuente por defecto).
        }
        
        // --- Comienza la magia ---
        main(gl);
    });

    function main(gl) {
        const textCanvas = document.createElement('canvas');
        const textCtx = textCanvas.getContext('2d');
        let textTexture;

        function drawTextOnCanvas() {
            const dpr = window.devicePixelRatio || 1;
            textCanvas.width = canvas.clientWidth * dpr;
            textCanvas.height = canvas.clientHeight * dpr;
            textCtx.clearRect(0, 0, textCanvas.width, textCanvas.height);
            textCtx.fillStyle = '#FFFFFF';
            textCtx.font = `${FONT_SIZE * dpr}px ${FONT_FAMILY}`;
            textCtx.textAlign = 'center';
            textCtx.textBaseline = 'middle';
            textCtx.fillText(TEXT_TO_ANIMATE, textCanvas.width / 2, textCanvas.height / 2);
        }

        drawTextOnCanvas();

        const { ext } = getWebGLExtensions(gl);
        
        const baseVertexShader = compileShader(gl, gl.VERTEX_SHADER, `
            precision highp float;
            attribute vec2 a_position;
            varying vec2 vUv;
            void main () {
                vUv = a_position * 0.5 + 0.5;
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `);

        const displayShader = compileShader(gl, gl.FRAGMENT_SHADER, `
            precision highp float;
            precision highp sampler2D;
            varying vec2 vUv;
            uniform sampler2D uTexture;
            uniform sampler2D uText;
            void main () {
                vec4 fluidColor = texture2D(uTexture, vUv);
                float textMask = texture2D(uText, vUv).a;
                if (textMask < 0.1) {
                    discard;
                }
                gl_FragColor = fluidColor;
            }
        `);

        // ... (El resto del código de los shaders y la simulación es extenso pero autocontenido)
        const splatShader = compileShader(gl, gl.FRAGMENT_SHADER,`precision highp float;precision highp sampler2D;varying vec2 vUv;uniform sampler2D uTarget;uniform float aspectRatio;uniform vec3 color;uniform vec2 point;uniform float radius;void main(){vec2 p=vUv-point.xy;p.x*=aspectRatio;vec3 splat=exp(-dot(p,p)/radius)*color;vec3 base=texture2D(uTarget,vUv).xyz;gl_FragColor=vec4(base+splat,1.0);}`);
        const advectionShader = compileShader(gl, gl.FRAGMENT_SHADER,`precision highp float;precision highp sampler2D;varying vec2 vUv;uniform sampler2D uVelocity;uniform sampler2D uSource;uniform vec2 texelSize;uniform float dt;uniform float dissipation;vec4 bilerp(sampler2D sam,vec2 uv){return texture2D(sam,uv);}void main(){vec2 coord=vUv-texture2D(uVelocity,vUv).xy*dt*texelSize;gl_FragColor=dissipation*bilerp(uSource,coord);gl_FragColor.a=1.0;}`);
        const divergenceShader = compileShader(gl, gl.FRAGMENT_SHADER,`precision highp float;precision highp sampler2D;varying vec2 vUv;varying vec2 vL;varying vec2 vR;varying vec2 vT;varying vec2 vB;uniform sampler2D uVelocity;void main(){float L=texture2D(uVelocity,vL).x;float R=texture2D(uVelocity,vR).x;float T=texture2D(uVelocity,vT).y;float B=texture2D(uVelocity,vB).y;vec2 C=texture2D(uVelocity,vUv).xy;if(vL.x<0.0){L=-C.x;}if(vR.x>1.0){R=-C.x;}if(vB.y<0.0){B=-C.y;}if(vT.y>1.0){T=-C.y;}float div=0.5*(R-L+T-B);gl_FragColor=vec4(div,0.0,0.0,1.0);}`);
        const curlShader = compileShader(gl, gl.FRAGMENT_SHADER,`precision highp float;precision highp sampler2D;varying vec2 vUv;varying vec2 vL;varying vec2 vR;varying vec2 vT;varying vec2 vB;uniform sampler2D uVelocity;void main(){float L=texture2D(uVelocity,vL).y;float R=texture2D(uVelocity,vR).y;float T=texture2D(uVelocity,vT).x;float B=texture2D(uVelocity,vB).x;float vorticity=R-L-T-B;gl_FragColor=vec4(0.5*vorticity,0.0,0.0,1.0);}`);
        const vorticityShader = compileShader(gl, gl.FRAGMENT_SHADER,`precision highp float;precision highp sampler2D;varying vec2 vUv;varying vec2 vL;varying vec2 vR;varying vec2 vT;varying vec2 vB;uniform sampler2D uVelocity;uniform sampler2D uCurl;uniform float curl;uniform float dt;void main(){float L=texture2D(uCurl,vL).x;float R=texture2D(uCurl,vR).x;float T=texture2D(uCurl,vT).x;float B=texture2D(uCurl,vB).x;float C=texture2D(uCurl,vUv).x;vec2 force=0.5*vec2(abs(T)-abs(B),abs(R)-abs(L));force/=length(force)+0.0001;force*=curl*C;force.y*=-1.0;vec2 vel=texture2D(uVelocity,vUv).xy;gl_FragColor=vec4(vel+force*dt,0.0,1.0);}`);
        const pressureShader = compileShader(gl, gl.FRAGMENT_SHADER,`precision highp float;precision highp sampler2D;varying vec2 vUv;varying vec2 vL;varying vec2 vR;varying vec2 vT;varying vec2 vB;uniform sampler2D uPressure;uniform sampler2D uDivergence;void main(){float L=texture2D(uPressure,vL).x;float R=texture2D(uPressure,vR).x;float T=texture2D(uPressure,vT).x;float B=texture2D(uPressure,vB).x;float C=texture2D(uPressure,vUv).x;float divergence=texture2D(uDivergence,vUv).x;float pressure=(L+R+B+T-divergence)*0.25;gl_FragColor=vec4(pressure,0.0,0.0,1.0);}`);
        const gradientSubtractShader = compileShader(gl, gl.FRAGMENT_SHADER,`precision highp float;precision highp sampler2D;varying vec2 vUv;varying vec2 vL;varying vec2 vR;varying vec2 vT;varying vec2 vB;uniform sampler2D uPressure;uniform sampler2D uVelocity;void main(){float L=texture2D(uPressure,vL).x;float R=texture2D(uPressure,vR).x;float T=texture2D(uPressure,vT).x;float B=texture2D(uPressure,vB).x;vec2 velocity=texture2D(uVelocity,vUv).xy;velocity.xy-=0.5*vec2(R-L,T-B);gl_FragColor=vec4(velocity,0.0,1.0);}`);
        
        const programs = {
            display: new GLProgram(baseVertexShader, displayShader),
            splat: new GLProgram(baseVertexShader, splatShader),
            advection: new GLProgram(baseVertexShader, advectionShader),
            divergence: new GLProgram(baseVertexShader, divergenceShader),
            curl: new GLProgram(baseVertexShader, curlShader),
            vorticity: new GLProgram(baseVertexShader, vorticityShader),
            pressure: new GLProgram(baseVertexShader, pressureShader),
            gradienSubtract: new GLProgram(baseVertexShader, gradientSubtractShader)
        };
        
        let dye, velocity, divergence, curl, pressure;
        let lastTime = Date.now();
        const pointers = [new pointerPrototype()];

        function initFramebuffers() {
            let simRes = getResolution(config.SIM_RESOLUTION);
            let dyeRes = getResolution(config.DYE_RESOLUTION);
            const format = ext.format;
            const type = ext.type;
            dye = createDoubleFBO(gl, dyeRes.width, dyeRes.height, format.internalFormat, format.format, type, gl.LINEAR);
            velocity = createDoubleFBO(gl, simRes.width, simRes.height, ext.formatRG.internalFormat, ext.formatRG.format, type, gl.NEAREST);
            divergence = createFBO(gl, simRes.width, simRes.height, ext.formatR.internalFormat, ext.formatR.format, type, gl.NEAREST);
            curl = createFBO(gl, simRes.width, simRes.height, ext.formatR.internalFormat, ext.formatR.format, type, gl.NEAREST);
            pressure = createDoubleFBO(gl, simRes.width, simRes.height, ext.formatR.internalFormat, ext.formatR.format, type, gl.NEAREST);
            updateTextTexture();
        }

        function updateTextTexture() {
            if (textTexture) gl.deleteTexture(textTexture);
            textTexture = createTextureFromCanvas(gl, textCanvas);
        }

        initFramebuffers();
        multipleSplats(parseInt(Math.random() * 20) + 5);

        function update() {
            const dt = calcDeltaTime();
            if (resizeCanvas()) {
                initFramebuffers();
                drawTextOnCanvas();
                updateTextTexture();
            }

            gl.viewport(0, 0, velocity.width, velocity.height);
            programs.advection.bind(gl);
            gl.uniform2f(programs.advection.uniforms.texelSize, 1.0 / velocity.width, 1.0 / velocity.height);
            gl.uniform1i(programs.advection.uniforms.uVelocity, velocity.read.attach(0));
            gl.uniform1i(programs.advection.uniforms.uSource, velocity.read.attach(0));
            gl.uniform1f(programs.advection.uniforms.dt, dt);
            gl.uniform1f(programs.advection.uniforms.dissipation, config.VELOCITY_DISSIPATION);
            blit(gl, velocity.write.fbo);
            velocity.swap();

            gl.viewport(0, 0, dye.width, dye.height);
            gl.uniform1i(programs.advection.uniforms.uVelocity, velocity.read.attach(0));
            gl.uniform1i(programs.advection.uniforms.uSource, dye.read.attach(1));
            gl.uniform1f(programs.advection.uniforms.dissipation, config.DENSITY_DISSIPATION);
            blit(gl, dye.write.fbo);
            dye.swap();

            for (let i = 0; i < pointers.length; i++) {
                const pointer = pointers[i];
                if (pointer.moved) {
                    pointer.moved = false;
                    splat(pointer.x, pointer.y, pointer.dx, pointer.dy, pointer.color);
                }
            }

            gl.viewport(0, 0, velocity.width, velocity.height);
            programs.curl.bind(gl);
            gl.uniform2f(programs.curl.uniforms.texelSize, 1.0 / velocity.width, 1.0 / velocity.height);
            gl.uniform1i(programs.curl.uniforms.uVelocity, velocity.read.attach(0));
            blit(gl, curl.fbo);

            programs.vorticity.bind(gl);
            gl.uniform2f(programs.vorticity.uniforms.texelSize, 1.0 / velocity.width, 1.0 / velocity.height);
            gl.uniform1i(programs.vorticity.uniforms.uVelocity, velocity.read.attach(0));
            gl.uniform1i(programs.vorticity.uniforms.uCurl, curl.attach(1));
            gl.uniform1f(programs.vorticity.uniforms.curl, config.CURL);
            gl.uniform1f(programs.vorticity.uniforms.dt, dt);
            blit(gl, velocity.write.fbo);
            velocity.swap();

            programs.divergence.bind(gl);
            gl.uniform2f(programs.divergence.uniforms.texelSize, 1.0 / velocity.width, 1.0 / velocity.height);
            gl.uniform1i(programs.divergence.uniforms.uVelocity, velocity.read.attach(0));
            blit(gl, divergence.fbo);

            programs.pressure.bind(gl);
            gl.uniform2f(programs.pressure.uniforms.texelSize, 1.0 / velocity.width, 1.0 / velocity.height);
            gl.uniform1i(programs.pressure.uniforms.uDivergence, divergence.attach(0));
            for (let i = 0; i < config.PRESSURE_ITERATIONS; i++) {
                gl.bindFramebuffer(gl.FRAMEBUFFER, pressure.write.fbo);
                gl.uniform1i(programs.pressure.uniforms.uPressure, pressure.read.attach(1));
                blit(gl, null);
                pressure.swap();
            }

            programs.gradienSubtract.bind(gl);
            gl.uniform2f(programs.gradienSubtract.uniforms.texelSize, 1.0 / velocity.width, 1.0 / velocity.height);
            gl.uniform1i(programs.gradienSubtract.uniforms.uPressure, pressure.read.attach(0));
            gl.uniform1i(programs.gradienSubtract.uniforms.uVelocity, velocity.read.attach(1));
            blit(gl, velocity.write.fbo);
            velocity.swap();

            gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            programs.display.bind(gl);
            gl.uniform1i(programs.display.uniforms.uTexture, dye.read.attach(0));
            gl.uniform1i(programs.display.uniforms.uText, textTexture.attach(1));
            blit(gl, null);

            requestAnimationFrame(update);
        }

        function splat(x, y, dx, dy, color) {
            gl.viewport(0, 0, velocity.width, velocity.height);
            programs.splat.bind(gl);
            gl.uniform1i(programs.splat.uniforms.uTarget, velocity.read.attach(0));
            gl.uniform1f(programs.splat.uniforms.aspectRatio, canvas.width / canvas.height);
            gl.uniform2f(programs.splat.uniforms.point, x / canvas.width, 1.0 - y / canvas.height);
            gl.uniform3f(programs.splat.uniforms.color, dx * config.SPLAT_FORCE, -dy * config.SPLAT_FORCE, 0.0);
            gl.uniform1f(programs.splat.uniforms.radius, config.SPLAT_RADIUS / 100.0);
            blit(gl, velocity.write.fbo);
            velocity.swap();

            gl.viewport(0, 0, dye.width, dye.height);
            gl.uniform1i(programs.splat.uniforms.uTarget, dye.read.attach(0));
            gl.uniform3f(programs.splat.uniforms.color, color.r, color.g, color.b);
            blit(gl, dye.write.fbo);
            dye.swap();
        }

        function multipleSplats(amount) {
            for (let i = 0; i < amount; i++) {
                const color = generateColor();
                color.r *= 10.0; color.g *= 10.0; color.b *= 10.0;
                const x = canvas.width * Math.random();
                const y = canvas.height * Math.random();
                const dx = 1000 * (Math.random() - 0.5);
                const dy = 1000 * (Math.random() - 0.5);
                splat(x, y, dx, dy, color);
            }
        }

        function calcDeltaTime() {
            let now = Date.now();
            let dt = (now - lastTime) / 1000.0;
            lastTime = now;
            return Math.min(dt, 0.0166);
        }

        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            if (canvas.width != canvas.clientWidth * dpr || canvas.height != canvas.clientHeight * dpr) {
                canvas.width = canvas.clientWidth * dpr;
                canvas.height = canvas.clientHeight * dpr;
                return true;
            }
            return false;
        }

        canvas.addEventListener('mousemove', e => {
            pointers[0].moved = pointers[0].down;
            pointers[0].dx = (e.offsetX - pointers[0].x) * 5;
            pointers[0].dy = (e.offsetY - pointers[0].y) * 5;
            pointers[0].x = e.offsetX;
            pointers[0].y = e.offsetY;
        });

        canvas.addEventListener('mousedown', () => {
            pointers[0].down = true;
            pointers[0].color = generateColor();
        });

        window.addEventListener('mouseup', () => {
            pointers[0].down = false;
        });
        
        update();
    }

    function getWebGLExtensions(gl) {
        const halfFloat = gl.getExtension('OES_texture_half_float');
        const support_linear_float = gl.getExtension('OES_texture_half_float_linear');
        const formatRGBA = { internalFormat: gl.RGBA, format: gl.RGBA };
        const formatRG = { internalFormat: gl.RG16F, format: gl.RG };
        const formatR = { internalFormat: gl.R16F, format: gl.RED };
        const type = halfFloat.HALF_FLOAT_OES;
        return { ext: { formatRGBA, formatRG, formatR, type }, support_linear_float };
    }

    function GLProgram(vertexShader, fragmentShader) {
        this.program = gl.createProgram();
        this.uniforms = {};
        gl.attachShader(this.program, vertexShader);
        gl.attachShader(this.program, fragmentShader);
        gl.linkProgram(this.program);
        if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) throw gl.getProgramInfoLog(this.program);
        const uniformCount = gl.getProgramParameter(this.program, gl.ACTIVE_UNIFORMS);
        for (let i = 0; i < uniformCount; i++) {
            const uniform = gl.getProgramActiveUniform(this.program, i);
            this.uniforms[uniform.name] = gl.getUniformLocation(this.program, uniform.name);
        }
    }
    GLProgram.prototype.bind = function (gl) { gl.useProgram(this.program); };

    function compileShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(shader);
        return shader;
    };
    
    const blit = (gl, destination) => {
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,-1,1,1,1,1,-1]), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0,1,2,0,2,3]), gl.STATIC_DRAW);
        gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(0);
        gl.bindFramebuffer(gl.FRAMEBUFFER, destination);
        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
    }
    
    function createFBO (gl, w, h, internalFormat, format, type, param) {
        gl.activeTexture(gl.TEXTURE0);
        let texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, param);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, param);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, w, h, 0, format, type, null);
        let fbo = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
        gl.viewport(0, 0, w, h);
        gl.clear(gl.COLOR_BUFFER_BIT);
        let attachment = { texture, fbo, width: w, height: h, attach(id){gl.activeTexture(gl.TEXTURE0+id);gl.bindTexture(gl.TEXTURE_2D,texture);return id;}};
        return attachment;
    }

    function createDoubleFBO (gl, w, h, internalFormat, format, type, param) {
        let fbo1 = createFBO(gl, w, h, internalFormat, format, type, param);
        let fbo2 = createFBO(gl, w, h, internalFormat, format, type, param);
        return { get read() { return fbo1 }, get write() { return fbo2 }, swap() { let temp=fbo1; fbo1=fbo2; fbo2=temp; }};
    }

    function createTextureFromCanvas(gl, canvas) {
        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
        return texture;
    }
    WebGLTexture.prototype.attach = function (id) { gl.activeTexture(gl.TEXTURE0 + id); gl.bindTexture(gl.TEXTURE_2D, this); return id; };
    
    function getResolution(resolution) {
        let aspectRatio = gl.drawingBufferWidth / gl.drawingBufferHeight;
        if (aspectRatio < 1) aspectRatio = 1.0 / aspectRatio;
        let min = Math.round(resolution);
        let max = Math.round(resolution * aspectRatio);
        return (gl.drawingBufferWidth > gl.drawingBufferHeight) ? { width: max, height: min } : { width: min, height: max };
    }

    function pointerPrototype() { this.x=0;this.y=0;this.dx=0;this.dy=0;this.down=false;this.moved=false;this.color=[30,0,300]; }

    function generateColor() { const c=HSVtoRGB(Math.random(),1.0,1.0);c.r*=0.15;c.g*=0.15;c.b*=0.15;return c; }
    function HSVtoRGB(h,s,v){let r,g,b,i,f,p,q,t;i=Math.floor(h*6);f=h*6-i;p=v*(1-s);q=v*(1-f*s);t=v*(1-(1-f)*s);switch(i%6){case 0:r=v,g=t,b=p;break;case 1:r=q,g=v,b=p;break;case 2:r=p,g=v,b=t;break;case 3:r=p,g=q,b=v;break;case 4:r=t,g=p,b=v;break;case 5:r=v,g=p,b=q;break;}return {r,g,b};}

    </script>
</body>
</html>
