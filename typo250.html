<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Tipografía Fluida - prueba 250</title>
    <style>
        /* La fuente se carga desde la ruta especificada */
        @font-face {
            font-family: 'MiTipografia'; /* Le damos un nombre para usarlo en el código */
            src: url('assets/fuentes/tipo250.ttf') format('truetype');
        }

        /* Estilos básicos de la página */
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000000;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .info {
            position: fixed;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.4);
            font-family: sans-serif;
            font-size: 14px;
            pointer-events: none;
            text-align: center;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    <div class="info">Mueve el cursor para interactuar con la tipografía</div>

    <script>
    'use strict';

    // ================================================================
    // --- PERSONALIZA TU ANIMACIÓN AQUÍ ---
    // ================================================================
    
    // El texto que quieres que aparezca en la pantalla.
    const TEXT_TO_ANIMATE = 'prueba 250'; 
    
    // El nombre de la fuente que definiste en el CSS (en @font-face).
    const FONT_FAMILY = 'MiTipografia';
    
    // El tamaño de la fuente en píxeles.
    const FONT_SIZE = 160; 

    // --- Configuración avanzada de la simulación (puedes experimentar con esto) ---
    const config = {
        SIM_RESOLUTION: 128,
        DYE_RESOLUTION: 1024,
        DENSITY_DISSIPATION: 1.2,
        VELOCITY_DISSIPATION: 0.3,
        PRESSURE: 0.8,
        PRESSURE_ITERATIONS: 20,
        CURL: 30,
        SPLAT_RADIUS: 0.3,
        SPLAT_FORCE: 6000,
        SHADING: true,
        COLORFUL: true,
        BACK_COLOR: { r: 0, g: 0, b: 0 }
    };

    // ================================================================
    // --- INICIO DEL CÓDIGO DE LA SIMULACIÓN (NO ES NECESARIO TOCAR) ---
    // ================================================================

    document.addEventListener('DOMContentLoaded', async () => {
        const canvas = document.getElementById('glCanvas');
        let gl;
        try {
            gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        } catch (e) {}

        if (!gl) {
            alert('Tu navegador no soporta WebGL. La animación no puede funcionar.');
            return;
        }

        // --- Carga de la fuente de forma segura ---
        const fontPath = 'assets/fuentes/tipo250.ttf';
        try {
            const font = new FontFace(FONT_FAMILY, `url(${fontPath})`);
            await font.load();
            document.fonts.add(font);
            console.log(`Fuente '${FONT_FAMILY}' cargada correctamente desde ${fontPath}`);
        } catch(err) {
            console.error(`Error al cargar la fuente desde ${fontPath}.`, err);
            alert(`No se pudo cargar la fuente. Verifica que la ruta '${fontPath}' sea correcta y que el archivo exista.`);
        }
        
        // --- Comienza la magia (pasando canvas como argumento) ---
        main(gl, canvas);
    });

    function main(gl, canvas) { // <-- CORRECCIÓN: Recibimos 'canvas' aquí
        const textCanvas = document.createElement('canvas');
        const textCtx = textCanvas.getContext('2d');
        let textTexture;

        function drawTextOnCanvas() {
            const dpr = window.devicePixelRatio || 1;
            // CORRECCIÓN: 'canvas' ahora está definido y es accesible aquí
            textCanvas.width = canvas.clientWidth * dpr;
            textCanvas.height = canvas.clientHeight * dpr;
            textCtx.clearRect(0, 0, textCanvas.width, textCanvas.height);
            textCtx.fillStyle = '#FFFFFF';
            textCtx.font = `${FONT_SIZE * dpr}px ${FONT_FAMILY}`;
            textCtx.textAlign = 'center';
            textCtx.textBaseline = 'middle';
            textCtx.fillText(TEXT_TO_ANIMATE, textCanvas.width / 2, textCanvas.height / 2);
        }

        drawTextOnCanvas();

        const { ext } = getWebGLExtensions(gl);
        
        const baseVertexShader = compileShader(gl, gl.VERTEX_SHADER, `precision highp float;attribute vec2 a_position;varying vec2 vUv;void main(){vUv=a_position*0.5+0.5;gl_Position=vec4(a_position,0.0,1.0);}`);
        const displayShader = compileShader(gl, gl.FRAGMENT_SHADER, `precision highp float;precision highp sampler2D;varying vec2 vUv;uniform sampler2D uTexture;uniform sampler2D uText;void main(){vec4 fluidColor=texture2D(uTexture,vUv);float textMask=texture2D(uText,vUv).a;if(textMask<0.1){discard;}gl_FragColor=fluidColor;}`);
        const splatShader = compileShader(gl, gl.FRAGMENT_SHADER,`precision highp float;precision highp sampler2D;varying vec2 vUv;uniform sampler2D uTarget;uniform float aspectRatio;uniform vec3 color;uniform vec2 point;uniform float radius;void main(){vec2 p=vUv-point.xy;p.x*=aspectRatio;vec3 splat=exp(-dot(p,p)/radius)*color;vec3 base=texture2D(uTarget,vUv).xyz;gl_FragColor=vec4(base+splat,1.0);}`);
        const advectionShader = compileShader(gl, gl.FRAGMENT_SHADER,`precision highp float;precision highp sampler2D;varying vec2 vUv;uniform sampler2D uVelocity;uniform sampler2D uSource;uniform vec2 texelSize;uniform float dt;uniform float dissipation;void main(){vec2 coord=vUv-texture2D(uVelocity,vUv).xy*dt*texelSize;gl_FragColor=dissipation*texture2D(uSource,coord);gl_FragColor.a=1.0;}`);
        const divergenceShader = compileShader(gl, gl.FRAGMENT_SHADER,`precision highp float;precision highp sampler2D;varying vec2 vUv;uniform sampler2D uVelocity;void main(){vec2 texelSize=1.0/vec2(textureSize(uVelocity,0));vec2 L=vUv-vec2(texelSize.x,0.0);vec2 R=vUv+vec2(texelSize.x,0.0);vec2 B=vUv-vec2(0.0,texelSize.y);vec2 T=vUv+vec2(0.0,texelSize.y);float L_v=texture2D(uVelocity,L).x;float R_v=texture2D(uVelocity,R).x;float B_v=texture2D(uVelocity,B).y;float T_v=texture2D(uVelocity,T).y;gl_FragColor=vec4(0.5*(R_v-L_v+T_v-B_v),0.0,0.0,1.0);}`);
        const curlShader = compileShader(gl, gl.FRAGMENT_SHADER,`precision highp float;precision highp sampler2D;varying vec2 vUv;uniform sampler2D uVelocity;void main(){vec2 texelSize=1.0/vec2(textureSize(uVelocity,0));vec2 L=vUv-vec2(texelSize.x,0.0);vec2 R=vUv+vec2(texelSize.x,0.0);vec2 B=vUv-vec2(0.0,texelSize.y);vec2 T=vUv+vec2(0.0,texelSize.y);float L_v=texture2D(uVelocity,L).y;float R_v=texture2D(uVelocity,R).y;float B_v=texture2D(uVelocity,B).x;float T_v=texture2D(uVelocity,T).x;gl_FragColor=vec4(0.5*(R_v-L_v-T_v+B_v),0.0,0.0,1.0);}`);
        const vorticityShader = compileShader(gl, gl.FRAGMENT_SHADER,`precision highp float;precision highp sampler2D;varying vec2 vUv;uniform sampler2D uVelocity;uniform sampler2D uCurl;uniform float curl;uniform float dt;void main(){vec2 texelSize=1.0/vec2(textureSize(uVelocity,0));vec2 L=vUv-vec2(texelSize.x,0.0);vec2 R=vUv+vec2(texelSize.x,0.0);vec2 B=vUv-vec2(0.0,texelSize.y);vec2 T=vUv+vec2(0.0,texelSize.y);float C=texture2D(uCurl,vUv).x;float L_c=texture2D(uCurl,L).x;float R_c=texture2D(uCurl,R).x;float B_c=texture2D(uCurl,B).x;float T_c=texture2D(uCurl,T).x;vec2 force=0.5*vec2(abs(T_c)-abs(B_c),abs(R_c)-abs(L_c));force/=length(force)+0.0001;force*=curl*C;force.y*=-1.0;vec2 vel=texture2D(uVelocity,vUv).xy;gl_FragColor=vec4(vel+force*dt,0.0,1.0);}`);
        const pressureShader = compileShader(gl, gl.FRAGMENT_SHADER,`precision highp float;precision highp sampler2D;varying vec2 vUv;uniform sampler2D uPressure;uniform sampler2D uDivergence;void main(){vec2 texelSize=1.0/vec2(textureSize(uPressure,0));vec2 L=vUv-vec2(texelSize.x,0.0);vec2 R=vUv+vec2(texelSize.x,0.0);vec2 B=vUv-vec2(0.0,texelSize.y);vec2 T=vUv+vec2(0.0,texelSize.y);float L_p=texture2D(uPressure,L).x;float R_p=texture2D(uPressure,R).x;float B_p=texture2D(uPressure,B).x;float T_p=texture2D(uPressure,T).x;float div=texture2D(uDivergence,vUv).x;gl_FragColor=vec4(0.25*(L_p+R_p+B_p+T_p-div),0.0,0.0,1.0);}`);
        const gradientSubtractShader = compileShader(gl, gl.FRAGMENT_SHADER,`precision highp float;precision highp sampler2D;varying vec2 vUv;uniform sampler2D uPressure;uniform sampler2D uVelocity;void main(){vec2 texelSize=1.0/vec2(textureSize(uPressure,0));vec2 L=vUv-vec2(texelSize.x,0.0);vec2 R=vUv+vec2(texelSize.x,0.0);vec2 B=vUv-vec2(0.0,texelSize.y);vec2 T=vUv+vec2(0.0,texelSize.y);float L_p=texture2D(uPressure,L).x;float R_p=texture2D(uPressure,R).x;float B_p=texture2D(uPressure,B).x;float T_p=texture2D(uPressure,T).x;vec2 vel=texture2D(uVelocity,vUv).xy;vel.xy-=0.5*vec2(R_p-L_p,T_p-B_p);gl_FragColor=vec4(vel,0.0,1.0);}`);

        const programs = {
            display: new GLProgram(gl, baseVertexShader, displayShader),
            splat: new GLProgram(gl, baseVertexShader, splatShader),
            advection: new GLProgram(gl, baseVertexShader, advectionShader),
            divergence: new GLProgram(gl, baseVertexShader, divergenceShader),
            curl: new GLProgram(gl, baseVertexShader, curlShader),
            vorticity: new GLProgram(gl, baseVertexShader, vorticityShader),
            pressure: new GLProgram(gl, baseVertexShader, pressureShader),
            gradienSubtract: new GLProgram(gl, baseVertexShader, gradientSubtractShader)
        };
        
        let dye, velocity, divergence, curl, pressure;
        let lastTime = Date.now();
        const pointers = [new pointerPrototype()];

        function initFramebuffers() {
            let simRes = getResolution(config.SIM_RESOLUTION);
            let dyeRes = getResolution(config.DYE_RESOLUTION);
            const format = ext.formatRGBA;
            const type = ext.type;
            dye = createDoubleFBO(gl, dyeRes.width, dyeRes.height, format.internalFormat, format.format, type, gl.LINEAR);
            velocity = createDoubleFBO(gl, simRes.width, simRes.height, ext.formatRG.internalFormat, ext.formatRG.format, type, gl.NEAREST);
            divergence = createFBO(gl, simRes.width, simRes.height, ext.formatR.internalFormat, ext.formatR.format, type, gl.NEAREST);
            curl = createFBO(gl, simRes.width, simRes.height, ext.formatR.internalFormat, ext.formatR.format, type, gl.NEAREST);
            pressure = createDoubleFBO(gl, simRes.width, simRes.height, ext.formatR.internalFormat, ext.formatR.format, type, gl.NEAREST);
        }

        initFramebuffers();
        multipleSplats(parseInt(Math.random() * 20) + 5);

        function update() {
            const dt = calcDeltaTime();
            if (resizeCanvas()) {
                initFramebuffers();
                drawTextOnCanvas();
            }
            updateTextTexture();

            gl.viewport(0, 0, velocity.width, velocity.height);
            programs.advection.bind(gl);
            gl.uniform2f(programs.advection.uniforms.texelSize, 1.0 / velocity.width, 1.0 / velocity.height);
            gl.uniform1i(programs.advection.uniforms.uVelocity, velocity.read.attach(0));
            gl.uniform1i(programs.advection.uniforms.uSource, velocity.read.attach(0));
            gl.uniform1f(programs.advection.uniforms.dt, dt);
            gl.uniform1f(programs.advection.uniforms.dissipation, config.VELOCITY_DISSIPATION);
            blit(gl, velocity.write.fbo);
            velocity.swap();

            gl.viewport(0, 0, dye.width, dye.height);
            gl.uniform1i(programs.advection.uniforms.uVelocity, velocity.read.attach(0));
            gl.uniform1i(programs.advection.uniforms.uSource, dye.read.attach(1));
            gl.uniform1f(programs.advection.uniforms.dissipation, config.DENSITY_DISSIPATION);
            blit(gl, dye.write.fbo);
            dye.swap();

            for (let i = 0; i < pointers.length; i++) {
                const pointer = pointers[i];
                if (pointer.moved) {
                    pointer.moved = false;
                    splat(pointer.x, pointer.y, pointer.dx, pointer.dy, pointer.color);
                }
            }

            gl.viewport(0, 0, velocity.width, velocity.height);
            programs.curl.bind(gl);
            gl.uniform1i(programs.curl.uniforms.uVelocity, velocity.read.attach(0));
            blit(gl, curl.fbo);

            programs.vorticity.bind(gl);
            gl.uniform1i(programs.vorticity.uniforms.uVelocity, velocity.read.attach(0));
            gl.uniform1i(programs.vorticity.uniforms.uCurl, curl.attach(1));
            gl.uniform1f(programs.vorticity.uniforms.curl, config.CURL);
            gl.uniform1f(programs.vorticity.uniforms.dt, dt);
            blit(gl, velocity.write.fbo);
            velocity.swap();

            programs.divergence.bind(gl);
            gl.uniform1i(programs.divergence.uniforms.uVelocity, velocity.read.attach(0));
            blit(gl, divergence.fbo);

            programs.pressure.bind(gl);
            for (let i = 0; i < config.PRESSURE_ITERATIONS; i++) {
                gl.bindFramebuffer(gl.FRAMEBUFFER, pressure.write.fbo);
                gl.uniform1i(programs.pressure.uniforms.uPressure, pressure.read.attach(1));
                gl.uniform1i(programs.pressure.uniforms.uDivergence, divergence.attach(0));
                blit(gl, null);
                pressure.swap();
            }

            programs.gradienSubtract.bind(gl);
            gl.uniform1i(programs.gradienSubtract.uniforms.uPressure, pressure.read.attach(0));
            gl.uniform1i(programs.gradienSubtract.uniforms.uVelocity, velocity.read.attach(1));
            blit(gl, velocity.write.fbo);
            velocity.swap();

            gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            programs.display.bind(gl);
            gl.uniform1i(programs.display.uniforms.uTexture, dye.read.attach(0));
            gl.uniform1i(programs.display.uniforms.uText, textTexture.attach(1));
            blit(gl, null);

            requestAnimationFrame(update);
        }
        
        function updateTextTexture() {
            if (textTexture) gl.deleteTexture(textTexture);
            textTexture = createTextureFromCanvas(gl, textCanvas);
        }

        function splat(x, y, dx, dy, color) {
            gl.viewport(0, 0, velocity.width, velocity.height);
            programs.splat.bind(gl);
            gl.uniform1i(programs.splat.uniforms.uTarget, velocity.read.attach(0));
            gl.uniform1f(programs.splat.uniforms.aspectRatio, canvas.width / canvas.height);
            gl.uniform2f(programs.splat.uniforms.point, x / canvas.width, 1.0 - y / canvas.height);
            gl.uniform3f(programs.splat.uniforms.color, dx * config.SPLAT_FORCE, -dy * config.SPLAT_FORCE, 0.0);
            gl.uniform1f(programs.splat.uniforms.radius, config.SPLAT_RADIUS / 100.0);
            blit(gl, velocity.write.fbo);
            velocity.swap();

            gl.viewport(0, 0, dye.width, dye.height);
            gl.uniform1i(programs.splat.uniforms.uTarget, dye.read.attach(0));
            gl.uniform3f(programs.splat.uniforms.color, color.r, color.g, color.b);
            blit(gl, dye.write.fbo);
            dye.swap();
        }

        function multipleSplats(amount) {
            for (let i = 0; i < amount; i++) {
                const color = generateColor();
                color.r *= 10.0; color.g *= 10.0; color.b *= 10.0;
                const x = canvas.width * Math.random();
                const y = canvas.height * Math.random();
                const dx = 1000 * (Math.random() - 0.5);
                const dy = 1000 * (Math.random() - 0.5);
                splat(x, y, dx, dy, color);
            }
        }

        function calcDeltaTime() {
            let now = Date.now();
            let dt = (now - lastTime) / 1000.0;
            lastTime = now;
            return Math.min(dt, 0.0166);
        }

        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            if (canvas.width != canvas.clientWidth * dpr || canvas.height != canvas.clientHeight * dpr) {
                canvas.width = canvas.clientWidth * dpr;
                canvas.height = canvas.clientHeight * dpr;
                return true;
            }
            return false;
        }

        canvas.addEventListener('mousemove', e => {
            pointers[0].moved = pointers[0].down;
            pointers[0].dx = (e.offsetX - pointers[0].x) * 5;
            pointers[0].dy = (e.offsetY - pointers[0].y) * 5;
            pointers[0].x = e.offsetX;
            pointers[0].y = e.offsetY;
        });

        canvas.addEventListener('mousedown', () => {
            pointers[0].down = true;
            pointers[0].color = generateColor();
        });

        window.addEventListener('mouseup', () => {
            pointers[0].down = false;
        });
        
        update();
    }
    
    // --- Funciones de utilidad de WebGL ---

    function getWebGLExtensions(gl) {
        const halfFloat = gl.getExtension('OES_texture_half_float');
        const support_linear_float = gl.getExtension('OES_texture_half_float_linear');
        let formatRGBA, formatRG, formatR;
        const type = halfFloat.HALF_FLOAT_OES;
        if(gl.getExtension('EXT_color_buffer_float')) {
            formatRGBA = { internalFormat: gl.RGBA32F, format: gl.RGBA };
            formatRG = { internalFormat: gl.RG32F, format: gl.RG };
            formatR = { internalFormat: gl.R32F, format: gl.RED };
        } else {
            formatRGBA = { internalFormat: gl.RGBA, format: gl.RGBA };
            formatRG = { internalFormat: gl.RGBA, format: gl.RGBA };
            formatR = { internalFormat: gl.RGBA, format: gl.RGBA };
        }
        return { ext: { formatRGBA, formatRG, formatR, type }, support_linear_float };
    }

    function GLProgram(gl, vertexShader, fragmentShader) {
        this.program = gl.createProgram();
        this.uniforms = {};
        gl.attachShader(this.program, vertexShader);
        gl.attachShader(this.program, fragmentShader);
        gl.linkProgram(this.program);
        if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) throw gl.getProgramInfoLog(this.program);
        const uniformCount = gl.getProgramParameter(this.program, gl.ACTIVE_UNIFORMS);
        for (let i = 0; i < uniformCount; i++) {
            const uniform = gl.getProgramActiveUniform(this.program, i);
            this.uniforms[uniform.name] = gl.getUniformLocation(this.program, uniform.name);
        }
    }
    GLProgram.prototype.bind = function (gl) { gl.useProgram(this.program); };

    function compileShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(shader);
        return shader;
    };
    
    const blit = (gl, destination) => {
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,-1,1,1,1,1,-1]), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0,1,2,0,2,3]), gl.STATIC_DRAW);
        gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(0);
        gl.bindFramebuffer(gl.FRAMEBUFFER, destination);
        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
    }
    
    function createFBO (gl, w, h, internalFormat, format, type, param) {
        gl.activeTexture(gl.TEXTURE0);
        let texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, param);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, param);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, w, h, 0, format, type, null);
        let fbo = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
        gl.viewport(0, 0, w, h);
        gl.clear(gl.COLOR_BUFFER_BIT);
        let attachment = { texture, fbo, width: w, height: h, attach(id){gl.activeTexture(gl.TEXTURE0+id);gl.bindTexture(gl.TEXTURE_2D,texture);return id;}};
        return attachment;
    }

    function createDoubleFBO (gl, w, h, internalFormat, format, type, param) {
        let fbo1 = createFBO(gl, w, h, internalFormat, format, type, param);
        let fbo2 = createFBO(gl, w, h, internalFormat, format, type, param);
        return { get read() { return fbo1 }, get write() { return fbo2 }, swap() { let temp=fbo1; fbo1=fbo2; fbo2=temp; }};
    }

    function createTextureFromCanvas(gl, canvas) {
        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
        return texture;
    }
    
    WebGLTexture.prototype.attach = function (id) {
        const { gl } = this;
        gl.activeTexture(gl.TEXTURE0 + id);
        gl.bindTexture(gl.TEXTURE_2D, this);
        return id;
    };
    
    function getResolution(resolution) {
        const canvas = document.getElementById('glCanvas');
        let aspectRatio = canvas.clientWidth / canvas.clientHeight;
        if (aspectRatio < 1) aspectRatio = 1.0 / aspectRatio;
        let min = Math.round(resolution);
        let max = Math.round(resolution * aspectRatio);
        return (canvas.clientWidth > canvas.clientHeight) ? { width: max, height: min } : { width: min, height: max };
    }

    function pointerPrototype() { this.x=0;this.y=0;this.dx=0;this.dy=0;this.down=false;this.moved=false;this.color=[30,0,300]; }
    function generateColor() { const c=HSVtoRGB(Math.random(),1.0,1.0);c.r*=0.15;c.g*=0.15;c.b*=0.15;return c; }
    function HSVtoRGB(h,s,v){let r,g,b,i,f,p,q,t;i=Math.floor(h*6);f=h*6-i;p=v*(1-s);q=v*(1-f*s);t=v*(1-(1-f)*s);switch(i%6){case 0:r=v,g=t,b=p;break;case 1:r=q,g=v,b=p;break;case 2:r=p,g=v,b=t;break;case 3:r=p,g=q,b=v;break;case 4:r=t,g=p,b=v;break;case 5:r=v,g=p,b=q;break;}return {r,g,b};}

    </script>
</body>
</html>
