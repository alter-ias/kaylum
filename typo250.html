<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Tipografía Fluida - Versión Final</title>
    <link rel="icon" href="data:,">
    <style>
        @font-face {
            font-family: 'MiTipografia';
            src: url('assets/fuentes/tipo250.ttf') format('truetype');
        }
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000000;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .info {
            position: fixed;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.4);
            font-family: sans-serif;
            font-size: 14px;
            pointer-events: none;
            text-align: center;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    <div class="info">Mueve el cursor para interactuar con la tipografía</div>

    <script>
    'use strict';

    // ================================================================
    // --- CONFIGURACIÓN ---
    // ================================================================
    const TEXT_TO_ANIMATE = 'prueba 250'; 
    const FONT_FAMILY = 'MiTipografia';
    const FONT_SIZE = 160; 

    const config = {
        SIM_RESOLUTION: 128,
        DYE_RESOLUTION: 1024,
        DENSITY_DISSIPATION: 0.98, // Parámetro seguro para que el color se vea.
        VELOCITY_DISSIPATION: 0.99,
        PRESSURE: 0.8,
        PRESSURE_ITERATIONS: 20,
        CURL: 30,
        SPLAT_RADIUS: 0.3,
        SPLAT_FORCE: 6000
    };

    // ================================================================
    // --- INICIO DEL CÓDIGO ---
    // ================================================================

    window.onload = function() {
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

        if (!gl) {
            alert('WebGL no está disponible en tu navegador.');
            return;
        }

        // Estructura de carga de fuente validada en el paso anterior.
        const font = new FontFace(FONT_FAMILY, `url(assets/fuentes/tipo250.ttf)`);
        font.load().then(loadedFont => {
            document.fonts.add(loadedFont);
            console.log("Fuente cargada. Iniciando animación sobre base verificada.");
            main(gl, canvas);
        }).catch(err => console.error("Error crítico al cargar la fuente:", err));
    };
    
    function main(gl, canvas) {
        const textCanvas = document.createElement('canvas');
        const textCtx = textCanvas.getContext('2d');
        let textTexture;

        function drawTextOnCanvas() {
            const dpr = window.devicePixelRatio || 1;
            textCanvas.width = canvas.clientWidth * dpr;
            textCanvas.height = canvas.clientHeight * dpr;
            textCtx.fillStyle = '#FFFFFF';
            textCtx.font = `${FONT_SIZE * dpr}px ${FONT_FAMILY}`;
            textCtx.textAlign = 'center';
            textCtx.textBaseline = 'middle';
            textCtx.fillText(TEXT_TO_ANIMATE, textCanvas.width / 2, textCanvas.height / 2);
        }

        const { ext } = getWebGLExtensions(gl);
        const baseVertexShader = compileShader(gl, gl.VERTEX_SHADER, `precision highp float;attribute vec2 a_position;varying vec2 vUv;varying vec2 vL;varying vec2 vR;varying vec2 vT;varying vec2 vB;uniform vec2 texelSize;void main(){vUv=a_position*0.5+0.5;vL=vUv-vec2(texelSize.x,0.0);vR=vUv+vec2(texelSize.x,0.0);vT=vUv+vec2(0.0,texelSize.y);vB=vUv-vec2(0.0,texelSize.y);gl_Position=vec4(a_position,0.0,1.0);}`);
        const displayShader = compileShader(gl, gl.FRAGMENT_SHADER, `precision highp float;precision highp sampler2D;varying vec2 vUv;uniform sampler2D uTexture;uniform sampler2D uText;void main(){vec4 fluidColor=texture2D(uTexture,vUv);float textMask=texture2D(uText,vUv).a;gl_FragColor=vec4(fluidColor.rgb*textMask,1.0);}`);
        const splatShader = compileShader(gl, gl.FRAGMENT_SHADER,`precision highp float;precision highp sampler2D;varying vec2 vUv;uniform sampler2D uTarget;uniform float aspectRatio;uniform vec3 color;uniform vec2 point;uniform float radius;void main(){vec2 p=vUv-point.xy;p.x*=aspectRatio;vec3 splat=exp(-dot(p,p)/radius)*color;vec3 base=texture2D(uTarget,vUv).xyz;gl_FragColor=vec4(base+splat,1.0);}`);
        const advectionShader = compileShader(gl, gl.FRAGMENT_SHADER,`precision highp float;precision highp sampler2D;varying vec2 vUv;uniform sampler2D uVelocity;uniform sampler2D uSource;uniform vec2 texelSize;uniform float dt;uniform float dissipation;void main(){vec2 coord=vUv-texture2D(uVelocity,vUv).xy*dt*texelSize;gl_FragColor=dissipation*texture2D(uSource,coord);gl_FragColor.a=1.0;}`);
        const divergenceShader = compileShader(gl, gl.FRAGMENT_SHADER,`precision highp float;precision highp sampler2D;varying vec2 vUv;varying vec2 vL;varying vec2 vR;varying vec2 vT;varying vec2 vB;uniform sampler2D uVelocity;void main(){float L=texture2D(uVelocity,vL).x;float R=texture2D(uVelocity,vR).x;float T=texture2D(uVelocity,vT).y;float B=texture2D(uVelocity,vB).y;vec2 C=texture2D(uVelocity,vUv).xy;if(vL.x<0.0){L=-C.x;}if(vR.x>1.0){R=-C.x;}if(vB.y<0.0){B=-C.y;}if(vT.y>1.0){T=-C.y;}float div=0.5*(R-L+T-B);gl_FragColor=vec4(div,0.0,0.0,1.0);}`);
        const curlShader = compileShader(gl, gl.FRAGMENT_SHADER,`precision highp float;precision highp sampler2D;varying vec2 vUv;varying vec2 vL;varying vec2 vR;varying vec2 vT;varying vec2 vB;uniform sampler2D uVelocity;void main(){float L=texture2D(uVelocity,vL).y;float R=texture2D(uVelocity,vR).y;float T=texture2D(uVelocity,vT).x;float B=texture2D(uVelocity,vB).x;float vorticity=R-L-T-B;gl_FragColor=vec4(0.5*vorticity,0.0,0.0,1.0);}`);
        const vorticityShader = compileShader(gl, gl.FRAGMENT_SHADER,`precision highp float;precision highp sampler2D;varying vec2 vUv;varying vec2 vL;varying vec2 vR;varying vec2 vT;varying vec2 vB;uniform sampler2D uVelocity;uniform sampler2D uCurl;uniform float curl;uniform float dt;void main(){float L=texture2D(uCurl,vL).x;float R=texture2D(uCurl,vR).x;float T=texture2D(uCurl,vT).x;float B=texture2D(uCurl,vB).x;float C=texture2D(uCurl,vUv).x;vec2 force=0.5*vec2(abs(T)-abs(B),abs(R)-abs(L));force/=length(force)+0.0001;force*=curl*C;force.y*=-1.0;vec2 vel=texture2D(uVelocity,vUv).xy;gl_FragColor=vec4(vel+force*dt,0.0,1.0);}`);
        const pressureShader = compileShader(gl, gl.FRAGMENT_SHADER,`precision highp float;precision highp sampler2D;varying vec2 vUv;varying vec2 vL;varying vec2 vR;varying vec2 vT;varying vec2 vB;uniform sampler2D uPressure;uniform sampler2D uDivergence;void main(){float L=texture2D(uPressure,vL).x;float R=texture2D(uPressure,vR).x;float T=texture2D(uPressure,vT).x;float B=texture2D(uPressure,vB).x;float div=texture2D(uDivergence,vUv).x;float pressure=(L+R+B+T-div)*0.25;gl_FragColor=vec4(pressure,0.0,0.0,1.0);}`);
        const gradientSubtractShader = compileShader(gl, gl.FRAGMENT_SHADER,`precision highp float;precision highp sampler2D;varying vec2 vUv;varying vec2 vL;varying vec2 vR;varying vec2 vT;varying vec2 vB;uniform sampler2D uPressure;uniform sampler2D uVelocity;void main(){float L=texture2D(uPressure,vL).x;float R=texture2D(uPressure,vR).x;float T=texture2D(uPressure,vT).x;float B=texture2D(uPressure,vB).x;vec2 vel=texture2D(uVelocity,vUv).xy;vel.xy-=0.5*vec2(R-L,T-B);gl_FragColor=vec4(vel,0.0,1.0);}`);

        const programs = {
            display: new GLProgram(gl, baseVertexShader, displayShader),
            splat: new GLProgram(gl, baseVertexShader, splatShader),
            advection: new GLProgram(gl, baseVertexShader, advectionShader),
            divergence: new GLProgram(gl, baseVertexShader, divergenceShader),
            curl: new GLProgram(gl, baseVertexShader, curlShader),
            vorticity: new GLProgram(gl, baseVertexShader, vorticityShader),
            pressure: new GLProgram(gl, baseVertexShader, pressureShader),
            gradienSubtract: new GLProgram(gl, baseVertexShader, gradientSubtractShader)
        };
        
        let dye, velocity, divergence, curl, pressure;
        let lastTime = Date.now();
        const pointers = [new pointerPrototype()];

        function initFramebuffers() {
            let simRes = getResolution(canvas, config.SIM_RESOLUTION);
            let dyeRes = getResolution(canvas, config.DYE_RESOLUTION);
            const format = ext.formatRGBA;
            const type = ext.type;
            dye = createDoubleFBO(gl, dyeRes.width, dyeRes.height, format.internalFormat, format.format, type, gl.LINEAR);
            velocity = createDoubleFBO(gl, simRes.width, simRes.height, ext.formatRG.internalFormat, ext.formatRG.format, type, gl.NEAREST);
            divergence = createFBO(gl, simRes.width, simRes.height, ext.formatR.internalFormat, ext.formatR.format, type, gl.NEAREST);
            curl = createFBO(gl, simRes.width, simRes.height, ext.formatR.internalFormat, ext.formatR.format, type, gl.NEAREST);
            pressure = createDoubleFBO(gl, simRes.width, simRes.height, ext.formatR.internalFormat, ext.formatR.format, type, gl.NEAREST);
        }

        function update() {
            const dt = calcDeltaTime();
            if (resizeCanvas()) {
                initFramebuffers();
                drawTextOnCanvas();
            }
            updateTextTexture(); // Actualizamos la textura en cada frame por si cambia el texto o tamaño.
            
            // ... (resto del bucle de simulación)
            gl.viewport(0, 0, velocity.width, velocity.height);
            programs.advection.bind(gl);
            gl.uniform2f(programs.advection.uniforms.texelSize, 1.0 / velocity.width, 1.0 / velocity.height);
            gl.uniform1i(programs.advection.uniforms.uVelocity, velocity.read.attach(0));
            gl.uniform1i(programs.advection.uniforms.uSource, velocity.read.attach(0));
            gl.uniform1f(programs.advection.uniforms.dt, dt);
            gl.uniform1f(programs.advection.uniforms.dissipation, config.VELOCITY_DISSIPATION);
            blit(gl, velocity.write.fbo);
            velocity.swap();

            gl.viewport(0, 0, dye.width, dye.height);
            gl.uniform1i(programs.advection.uniforms.uVelocity, velocity.read.attach(0));
            gl.uniform1i(programs.advection.uniforms.uSource, dye.read.attach(1));
            gl.uniform1f(programs.advection.uniforms.dissipation, config.DENSITY_DISSIPATION);
            blit(gl, dye.write.fbo);
            dye.swap();

            for (let i = 0; i < pointers.length; i++) {
                const pointer = pointers[i];
                if (pointer.moved) {
                    pointer.moved = false;
                    splat(pointer.x, pointer.y, pointer.dx, pointer.dy, pointer.color);
                }
            }

            gl.viewport(0, 0, velocity.width, velocity.height);
            programs.curl.bind(gl);
            gl.uniform2f(programs.curl.uniforms.texelSize, 1.0 / velocity.width, 1.0 / velocity.height);
            gl.uniform1i(programs.curl.uniforms.uVelocity, velocity.read.attach(0));
            blit(gl, curl.fbo);

            programs.vorticity.bind(gl);
            gl.uniform2f(programs.vorticity.uniforms.texelSize, 1.0 / velocity.width, 1.0 / velocity.height);
            gl.uniform1i(programs.vorticity.uniforms.uVelocity, velocity.read.attach(0));
            gl.uniform1i(programs.vorticity.uniforms.uCurl, curl.attach(1));
            gl.uniform1f(programs.vorticity.uniforms.curl, config.CURL);
            gl.uniform1f(programs.vorticity.uniforms.dt, dt);
            blit(gl, velocity.write.fbo);
            velocity.swap();

            programs.divergence.bind(gl);
            gl.uniform2f(programs.divergence.uniforms.texelSize, 1.0 / velocity.width, 1.0 / velocity.height);
            gl.uniform1i(programs.divergence.uniforms.uVelocity, velocity.read.attach(0));
            blit(gl, divergence.fbo);

            programs.pressure.bind(gl);
            gl.uniform2f(programs.pressure.uniforms.texelSize, 1.0 / velocity.width, 1.0 / velocity.height);
            gl.uniform1i(programs.pressure.uniforms.uDivergence, divergence.attach(0));
            for (let i = 0; i < config.PRESSURE_ITERATIONS; i++) {
                gl.bindFramebuffer(gl.FRAMEBUFFER, pressure.write.fbo);
                gl.uniform1i(programs.pressure.uniforms.uPressure, pressure.read.attach(1));
                blit(gl, null);
                pressure.swap();
            }

            programs.gradienSubtract.bind(gl);
            gl.uniform2f(programs.gradienSubtract.uniforms.texelSize, 1.0 / velocity.width, 1.0 / velocity.height);
            gl.uniform1i(programs.gradienSubtract.uniforms.uPressure, pressure.read.attach(0));
            gl.uniform1i(programs.gradienSubtract.uniforms.uVelocity, velocity.read.attach(1));
            blit(gl, velocity.write.fbo);
            velocity.swap();

            gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            programs.display.bind(gl);
            gl.uniform1i(programs.display.uniforms.uTexture, dye.read.attach(0));
            
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, textTexture);
            gl.uniform1i(programs.display.uniforms.uText, 1);
            
            blit(gl, null);

            requestAnimationFrame(update);
        }
        
        // ... (resto de funciones de utilidad sin cambios)
        initFramebuffers();
        multipleSplats(parseInt(Math.random() * 20) + 10);
        
        function updateTextTexture() {
            if (textTexture) { gl.deleteTexture(textTexture); }
            textTexture = createTextureFromCanvas(gl, textCanvas);
        }

        function splat(x, y, dx, dy, color) {
            gl.viewport(0, 0, velocity.width, velocity.height);
            programs.splat.bind(gl);
            gl.uniform1i(programs.splat.uniforms.uTarget, velocity.read.attach(0));
            gl.uniform1f(programs.splat.uniforms.aspectRatio, canvas.width / canvas.height);
            gl.uniform2f(programs.splat.uniforms.point, x / can
